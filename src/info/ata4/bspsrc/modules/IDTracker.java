/*
 ** 2013 May 23
 **
 ** The author disclaims copyright to this source code.  In place of
 ** a legal notice, here is a blessing:
 **    May you do good and not evil.
 **    May you find forgiveness for yourself and forgive others.
 **    May you share freely, never taking more than you give.
 */
package info.ata4.bspsrc.modules;

import info.ata4.bsplib.BspFileReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Module to keep track on various IDs and their mappings.
 * 
 * @author Nico Bergemann <barracuda415 at yahoo.de>
 */
public class IDTracker extends ModuleRead {
    
    // UID mappings
    private Map<Integer, Integer> faceUIDs = new HashMap<Integer, Integer>();
    private Map<Integer, Integer> origFaceUIDs = new HashMap<Integer, Integer>();
    private Map<Short, Integer> dispinfoUIDs = new HashMap<Short, Integer>();
    
    // UID blacklist
    private Set<Integer> uidbl = new HashSet<Integer>();
    
    // VMF unique ID
    private int uid = 0;
    
    public IDTracker(BspFileReader reader) {
        super(reader);
    }
    
    public Set<Integer> getUIDBlackList() {
        return uidbl;
    }

    /**
     * Returns a new VMF unique ID.
     * 
     * @return UID
     */
    public int getUID() {
        if (uidbl.isEmpty()) {
            return uid++;
        } else {
            // increment ID until it's not found in the blacklist anymore
            do {
                uid++;
            } while (uidbl.contains(uid));
            
            return uid;
        }
    }
    
    /**
     * Returns the VMF UID for the corresponding face index.
     * It automatically looks up the original face if the split face wasn't found.
     * 
     * @param iface face index
     * @return brush side ID or -1 if the index isn't mapped yet
     */
    public int getFaceUID(int iface) {
        if (faceUIDs.containsKey(iface)) {
            return faceUIDs.get(iface);
        } else {
            // try origface
            int ioface = bsp.faces.get(iface).origFace;
            if (origFaceUIDs.containsKey(ioface)) {
                return origFaceUIDs.get(ioface);
            }
        }
        
        // not found
        return -1;
    }
    
    /**
     * Sets the VMF UID for the given face index.
     * 
     * @param iface face index
     * @param id VMF UID generated by {@link #getUID}
     * @return previously mapped UID or <tt>null</tt> if there was no mapping
     */
    public Integer setFaceUID(int iface, int id) {
        return faceUIDs.put(iface, id);
    }
    
    /**
     * Sets the VMF UID for the given original face index.
     * 
     * @param iface face index
     * @param id VMF UID generated by {@link #getUID}
     * @return previously mapped UID or <tt>null</tt> if there was no mapping
     */
    public Integer setOrigFaceUID(int iface, int id) {
        return origFaceUIDs.put(iface, id);
    }
    
    /**
     * Returns the VMF UID for the corresponding dispInfo index.
     * 
     * @param idispinfo dispinfo index
     * @return brush side ID or -1 if the index isn't mapped yet
     */
    public int getDispInfoUID(short idispinfo) {
        if (dispinfoUIDs.containsKey(idispinfo)) {
            return dispinfoUIDs.get(idispinfo);
        }
        
        // not found
        return -1;
    }
    
    /**
     * Sets the VMF UID for the given displacement info index.
     * 
     * @param idispinfo dispinfo index
     * @param id VMF UID generated by {@link #getUID}
     * @return previously mapped UID or <tt>null</tt> if there was no mapping
     */
    public Integer setDispInfoUID(short idispinfo, int id) {
        return dispinfoUIDs.put(idispinfo, id);
    }
}
